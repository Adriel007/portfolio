<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>MNIST Neural Network Visualizer 3D</title>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #050505;
        font-family: "Courier New", monospace;
      }
      #container {
        display: flex;
        height: 100vh;
      }
      #ui-panel {
        width: 320px;
        background: rgba(10, 10, 20, 0.9);
        padding: 20px;
        border-right: 1px solid #00ffff44;
        z-index: 10;
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        overflow-y: auto;
      }
      #draw-canvas {
        background: black;
        border: 2px solid #00ffff;
        cursor: crosshair;
        box-shadow: 0 0 15px #00ffff44;
      }
      button {
        margin-top: 10px;
        background: transparent;
        border: 1px solid #00ffff;
        color: #00ffff;
        padding: 10px 20px;
        cursor: pointer;
        transition: 0.3s;
      }
      button:hover {
        background: #00ffff22;
        box-shadow: 0 0 10px #00ffff;
      }
      h2 {
        color: #00ffff;
        margin-bottom: 5px;
        text-shadow: 0 0 5px #00ffff;
      }
      #loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        color: #00ffff;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2em;
        z-index: 100;
      }
      .instruction {
        font-size: 0.8em;
        color: #aaa;
        margin-bottom: 10px;
        text-align: center;
      }
      #prediction-results {
        width: 100%;
        text-align: left;
        font-size: 0.85em;
      }
    </style>
  </head>
  <body>
    <div id="loading-overlay">Loading TensorFlow.js Model...</div>
    <div id="container">
      <div id="ui-panel">
        <h2>Input</h2>
        <p class="instruction">Draw a number (0-9)</p>
        <canvas id="draw-canvas" width="280" height="280"></canvas>
        <button onclick="clearCanvas()">Clear / Reset</button>

        <h2 style="margin-top: 30px">Output</h2>
        <div id="prediction-results"></div>
      </div>
      <div id="threejs-container" style="flex-grow: 1"></div>
    </div>

    <script>
      const canvas = document.getElementById("draw-canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      let isDrawing = false;

      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "white";
      ctx.lineWidth = 20;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      canvas.addEventListener("mousedown", (e) => {
        isDrawing = true;
        ctx.beginPath();
        draw(e);
      });
      canvas.addEventListener("mousemove", draw);
      canvas.addEventListener("mouseup", () => {
        isDrawing = false;
        predictAndVisualize();
      });
      canvas.addEventListener("mouseout", () => {
        isDrawing = false;
      });

      function draw(e) {
        if (!isDrawing) return;
        const rect = canvas.getBoundingClientRect();
        ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
        ctx.stroke();
      }

      window.clearCanvas = function () {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        resetVisuals();
      };

      let model;

      async function loadModel() {
        try {
          const isInIframe = window.self !== window.top;

          let modelPath = "model.json";

          console.log("Attempting to load model | In iframe:", isInIframe);

          try {
            model = await tf.loadGraphModel(modelPath);
            console.log("✓ Model loaded successfully with path:", modelPath);
          } catch (firstError) {
            console.log("First attempt failed, trying alternative path...");
            modelPath = "./assets/demos/mnist/model.json";
            model = await tf.loadGraphModel(modelPath);
            console.log("✓ Model loaded successfully with path:", modelPath);
          }

          document.getElementById("loading-overlay").style.display = "none";
        } catch (e) {
          console.error("Erro ao carregar:", e);
          document.getElementById("loading-overlay").innerHTML =
            "❌ Error: " +
            e.message +
            "<br>Verify if model.json and group1-shard1of1.bin are in the same directory";
        }
      }

      loadModel();

      function getTensorFromCanvas() {
        return tf.tidy(() => {
          let tensor = tf.browser.fromPixels(canvas, 1);
          const resized = tf.image.resizeBilinear(tensor, [28, 28]);
          const normalized = resized.toFloat().div(tf.scalar(255.0));
          const flattened = normalized.reshape([1, 784]);
          return flattened;
        });
      }

      async function predictAndVisualize() {
        if (!model) return;

        try {
          const inputTensor = getTensorFromCanvas();

          const prediction = model.predict(inputTensor);
          const outputArray = await prediction.array();
          const outputData = new Float32Array(outputArray[0]);

          const imageData = tf.tidy(() => {
            const tensor = tf.browser.fromPixels(canvas, 1);
            const resized = tf.image.resizeBilinear(tensor, [28, 28]);
            const normalized = resized.toFloat().div(tf.scalar(255.0));
            return normalized;
          });
          const inputArray = await imageData.array();
          const inputDataSync = new Float32Array(
            inputArray.flat().map((x) => (Array.isArray(x) ? x[0] : x))
          );

          const layer1Data = generateIntermediateLayer(inputDataSync, 128);
          const layer2Data = generateIntermediateLayer(layer1Data, 64);

          updateVisuals(inputDataSync, layer1Data, layer2Data, outputData);
          updateResultsUI(outputData);

          inputTensor.dispose();
          prediction.dispose();
          imageData.dispose();
        } catch (e) {
          console.error("Error during prediction:", e);
        }
      }

      function generateIntermediateLayer(prevLayer, newSize) {
        const result = new Float32Array(newSize);
        const avgPerNeuron = prevLayer.length / newSize;
        for (let i = 0; i < newSize; i++) {
          let sum = 0;
          for (let j = 0; j < avgPerNeuron; j++) {
            const idx = Math.floor(i * avgPerNeuron + j);
            if (idx < prevLayer.length) sum += prevLayer[idx];
          }
          result[i] = Math.tanh(sum / avgPerNeuron);
        }
        return result;
      }

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050505, 0.008);

      const width = window.innerWidth - 320;
      const height = window.innerHeight;

      const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
      camera.position.set(20, 10, 90);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(width, height);
      renderer.setClearColor(0x050505, 1);
      document
        .getElementById("threejs-container")
        .appendChild(renderer.domElement);

      let controls = {
        enableDamping: false,
        autoRotate: false,
        rotationSpeed: 0.005,
        theta: 0,
        phi: Math.PI / 4,
        radius: 90,
        isDragging: false,
        previousMousePosition: { x: 0, y: 0 },

        update: function () {
          const x = this.radius * Math.sin(this.phi) * Math.cos(this.theta);
          const y = this.radius * Math.cos(this.phi);
          const z = this.radius * Math.sin(this.phi) * Math.sin(this.theta);
          camera.position.set(x, y, z);
          camera.lookAt(0, 0, 0);
        },
      };

      renderer.domElement.addEventListener("mousedown", (e) => {
        controls.isDragging = true;
        controls.previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      renderer.domElement.addEventListener("mousemove", (e) => {
        if (controls.isDragging) {
          const deltaX = e.clientX - controls.previousMousePosition.x;
          const deltaY = e.clientY - controls.previousMousePosition.y;

          controls.theta -= deltaX * controls.rotationSpeed;
          controls.phi -= deltaY * controls.rotationSpeed;

          controls.phi = Math.max(0.1, Math.min(Math.PI - 0.1, controls.phi));

          controls.previousMousePosition = { x: e.clientX, y: e.clientY };
          controls.update();
        }
      });

      renderer.domElement.addEventListener("mouseup", () => {
        controls.isDragging = false;
      });

      renderer.domElement.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          controls.radius += e.deltaY * 0.05;
          controls.radius = Math.max(20, Math.min(200, controls.radius));
          controls.update();
        },
        { passive: false }
      );

      function createTextSprite(text, size = 20) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 256;
        canvas.height = 256;
        context.fillStyle = "#00ffff";
        context.font = "bold " + size + "px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(text, 128, 128);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(30, 30, 1);
        return sprite;
      }

      const layers = [];
      const layerConfigs = [
        {
          units: 784,
          rows: 28,
          cols: 28,
          type: "grid",
          z: 60,
          color: 0xaaaaaa,
          label: "Input (28x28)",
        },
        {
          units: 128,
          rows: 16,
          cols: 8,
          type: "dense",
          z: 20,
          color: 0x00ffff,
          label: "Hidden 1 (128)",
        },
        {
          units: 64,
          rows: 8,
          cols: 8,
          type: "dense",
          z: -20,
          color: 0xff00ff,
          label: "Hidden 2 (64)",
        },
        {
          units: 10,
          rows: 2,
          cols: 5,
          type: "output",
          z: -60,
          color: 0xffaa00,
          label: "Output (10)",
        },
      ];

      layerConfigs.forEach((config, layerIdx) => {
        const group = new THREE.Group();
        group.userData.neurons = [];
        group.userData.labels = [];

        const label = createTextSprite(config.label, 16);
        label.position.set(0, -config.rows * 1.5, config.z);
        group.add(label);

        const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const material = new THREE.MeshBasicMaterial({
          color: config.color,
          transparent: true,
          opacity: 0.1,
        });

        const rows = config.rows;
        const cols = config.cols;
        const startX = -(cols * 1.2) / 2;
        const startY = (rows * 1.2) / 2;

        for (let i = 0; i < config.units; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;

          const neuron = new THREE.Mesh(geometry, material.clone());
          const x = startX + col * 1.2;
          const y = startY - row * 1.2;

          neuron.position.set(x, y, config.z);
          group.add(neuron);
          group.userData.neurons.push(neuron);

          if (config.type === "output") {
            const neuronLabel = createTextSprite(i.toString(), 12);
            neuronLabel.position.set(x, y, config.z + 5);
            group.add(neuronLabel);
            group.userData.labels.push(neuronLabel);
          }
        }

        scene.add(group);
        layers.push(group);
      });

      const lineMat = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.03,
      });
      for (let l = 1; l < layers.length; l++) {
        const prev = layers[l - 1].userData.neurons;
        const curr = layers[l].userData.neurons;
        const geometry = new THREE.BufferGeometry();
        const points = [];

        for (let i = 0; i < 500; i++) {
          const n1 = prev[Math.floor(Math.random() * prev.length)];
          const n2 = curr[Math.floor(Math.random() * curr.length)];
          points.push(n1.position.x, n1.position.y, n1.position.z);
          points.push(n2.position.x, n2.position.y, n2.position.z);
        }
        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(points, 3)
        );
        scene.add(new THREE.LineSegments(geometry, lineMat));
      }

      function updateVisuals(inputs, l1, l2, outputs) {
        layers[0].userData.neurons.forEach((mesh, i) => {
          const val = inputs[i] || 0;
          mesh.material.opacity = 0.1 + val * 0.9;
          mesh.material.color.setScalar(val);
          mesh.scale.z = 1 + val * 5;
        });

        const updateLayer = (layerIdx, data) => {
          layers[layerIdx].userData.neurons.forEach((mesh, i) => {
            let val = Math.max(0, data[i] || 0);
            mesh.material.opacity = 0.1 + Math.min(val, 1) * 0.9;
            mesh.scale.setScalar(1 + Math.min(val, 1) * 2);
          });
        };

        updateLayer(1, l1);
        updateLayer(2, l2);

        layers[3].userData.neurons.forEach((mesh, i) => {
          const val = outputs[i] || 0;
          mesh.material.opacity = 0.2 + val * 0.8;
          mesh.scale.setScalar(1 + val * 3);
          mesh.material.color.setHex(val > 0.5 ? 0x00ff00 : 0xffaa00);
        });
      }

      function resetVisuals() {
        layers.forEach((l) =>
          l.userData.neurons.forEach((n) => {
            n.material.opacity = 0.1;
            n.scale.setScalar(1);
            if (l === layers[3]) n.material.color.setHex(0xffaa00);
          })
        );
        document.getElementById("prediction-results").innerHTML = "";
      }

      function updateResultsUI(data) {
        const div = document.getElementById("prediction-results");
        div.innerHTML = "";

        let maxI = 0;
        for (let i = 0; i < 10; i++)
          if ((data[i] || 0) > (data[maxI] || 0)) maxI = i;

        data.forEach((val, i) => {
          const p = document.createElement("div");
          const pct = ((val || 0) * 100).toFixed(1);
          p.style.marginBottom = "4px";
          p.style.color = i === maxI ? "#00ff00" : "#555";
          p.style.fontWeight = i === maxI ? "bold" : "normal";

          const bar = "█".repeat(Math.floor((val || 0) * 20));
          p.innerText = `${i}: ${pct}% ${bar}`;
          div.appendChild(p);
        });
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        const w = window.innerWidth - 320;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    </script>
  </body>
</html>
