<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cellular Automata 3D</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #111;
        font-family: "Courier New", monospace;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";

      const CONFIG = {
        gridSize: 60,
        speed: 100,
        color: 0x00d2ff,
        rule: "B3/S23",
        preset: "Conway (B3/S23)",
        isRunning: true,
      };

      const PRESETS = {
        "Conway (B3/S23)": "B3/S23",
        "Life 4555 (B45/S55)": "B45/S55",
        "Walled City (B467/S35678)": "B467/S35678",
        "Long Life (B3/S345)": "B3/S345",
      };

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);
      scene.fog = new THREE.FogExp2(0x111111, 0.003);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 60, 60);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document
        .getElementById("canvas-container")
        .appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      const ambientLight = new THREE.AmbientLight(0x404040, 2); // Luz base suave
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 2);
      dirLight.position.set(20, 50, 20);
      dirLight.castShadow = true;
      scene.add(dirLight);

      let cells = [];
      let buffer = [];
      const totalCells = CONFIG.gridSize * CONFIG.gridSize;

      function initGrid() {
        cells = new Uint8Array(totalCells);
        buffer = new Uint8Array(totalCells);
        for (let i = 0; i < totalCells; i++) {
          cells[i] = Math.random() > 0.75 ? 1 : 0;
        }
      }
      initGrid();

      const geometry = new THREE.BoxGeometry(0.9, 0.5, 0.9);
      const material = new THREE.MeshPhysicalMaterial({
        color: CONFIG.color,
        metalness: 0.1,
        roughness: 0.2,
        clearcoat: 1.0,
        transparent: true,
        opacity: 0.9,
      });

      const mesh = new THREE.InstancedMesh(geometry, material, totalCells);
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);

      const dummy = new THREE.Object3D();
      function parseRule(ruleStr) {
        const parts = ruleStr.split("/");
        const birth = parts[0].replace("B", "").split("").map(Number);
        const survive = parts[1].replace("S", "").split("").map(Number);
        return { b: new Set(birth), s: new Set(survive) };
      }

      function updateCA() {
        const size = CONFIG.gridSize;
        const { b, s } = parseRule(CONFIG.rule);

        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const i = y * size + x;

            let neighbors = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = (x + dx + size) % size;
                const ny = (y + dy + size) % size;
                neighbors += cells[ny * size + nx];
              }
            }

            const status = cells[i];
            if (status === 1 && s.has(neighbors)) buffer[i] = 1;
            else if (status === 0 && b.has(neighbors)) buffer[i] = 1;
            else buffer[i] = 0;
          }
        }

        cells.set(buffer);
        updateVisuals();
      }

      function updateVisuals() {
        const size = CONFIG.gridSize;
        const offset = size / 2;
        let activeCount = 0;

        for (let i = 0; i < totalCells; i++) {
          if (cells[i] === 1) {
            const x = (i % size) - offset;
            const z = Math.floor(i / size) - offset;

            dummy.position.set(x, 0, z);
            dummy.scale.set(1, 1, 1);
            dummy.updateMatrix();
            mesh.setMatrixAt(activeCount++, dummy.matrix);
          }
        }

        mesh.count = activeCount;
        mesh.instanceMatrix.needsUpdate = true;
      }

      const gui = new GUI({ title: "Options" });

      const folderRules = gui.addFolder("Rules & Presets");
      folderRules
        .add(CONFIG, "preset", Object.keys(PRESETS))
        .name("Select Preset")
        .onChange((val) => {
          CONFIG.rule = PRESETS[val];
          ruleController.object.rule = PRESETS[val];
          ruleController.updateDisplay();
          initGrid();
        });

      const ruleController = folderRules
        .add(CONFIG, "rule")
        .name("Custom Rule (B/S)");

      const folderSim = gui.addFolder("Simulation");
      folderSim.add(CONFIG, "speed", 10, 1000).name("Interval (ms)");
      folderSim
        .addColor(CONFIG, "color")
        .name("Block Color")
        .onChange((c) => material.color.set(c));
      folderSim.add(CONFIG, "isRunning").name("Animate");
      folderSim.add({ reset: initGrid }, "reset").name("Reset Grid");

      let lastUpdate = 0;

      function animate(time) {
        requestAnimationFrame(animate);

        if (CONFIG.isRunning && time - lastUpdate > CONFIG.speed) {
          updateCA();
          lastUpdate = time;
        }

        controls.update();
        renderer.render(scene, camera);
      }

      updateVisuals();
      animate(0);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
