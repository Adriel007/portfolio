<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NLP Pipeline - Custom Config</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #050505;
        font-family: "Latin Modern Math", "Cambria Math", monospace;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      #ui {
        position: absolute;
        bottom: 40px;
        width: 100%;
        text-align: center;
        z-index: 10;
        pointer-events: none;
        opacity: 0;
        transition: opacity 1s;
      }

      .btn-group {
        pointer-events: auto;
        display: inline-flex;
        gap: 15px;
        background: rgba(20, 20, 20, 0.8);
        padding: 10px 20px;
        border-radius: 30px;
        border: 1px solid #333;
        backdrop-filter: blur(10px);
      }

      button {
        background: transparent;
        border: none;
        color: #88c0d0;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        padding: 8px 16px;
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      button:hover {
        color: #fff;
        text-shadow: 0 0 8px rgba(136, 192, 208, 0.6);
      }
      button:disabled {
        color: #4c566a;
        cursor: default;
      }

      #title-overlay {
        position: absolute;
        top: 30px;
        left: 40px;
        color: #eceff4;
        font-size: 24px;
        font-weight: lighter;
        border-left: 3px solid #88c0d0;
        padding-left: 15px;
        opacity: 0;
        transition: opacity 1s;
        z-index: 5;
      }
      .subtitle {
        font-size: 14px;
        color: #81a1c1;
        margin-top: 5px;
        display: block;
      }

      #debug-console {
        position: absolute;
        top: 30px;
        right: 40px;
        width: 250px;
        font-size: 12px;
        color: #4c566a;
        text-align: right;
        font-family: monospace;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
        z-index: 5;
        opacity: 0;
        transition: opacity 1s;
      }

      #modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(5, 5, 5, 0.95);
        backdrop-filter: blur(5px);
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.5s;
      }

      #modal-box {
        width: 600px;
        max-width: 90%;
        background: #151515;
        border: 1px solid #333;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        text-align: left;
      }

      #modal-box h2 {
        color: #eceff4;
        margin-top: 0;
        font-weight: lighter;
        border-bottom: 2px solid #88c0d0;
        display: inline-block;
        padding-bottom: 5px;
        margin-bottom: 20px;
      }

      #modal-box p {
        color: #81a1c1;
        font-size: 14px;
        margin-bottom: 10px;
      }

      textarea#corpus-input {
        width: 100%;
        height: 150px;
        background: #0a0a0a;
        border: 1px solid #4c566a;
        color: #d8dee9;
        font-family: monospace;
        padding: 15px;
        font-size: 14px;
        resize: vertical;
        outline: none;
        box-sizing: border-box;
        margin-bottom: 20px;
        border-radius: 4px;
      }

      .settings-row {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
      }

      .input-group {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .input-group label {
        color: #88c0d0;
        font-size: 12px;
        margin-bottom: 5px;
        font-weight: bold;
      }

      .input-group input {
        background: #0a0a0a;
        border: 1px solid #4c566a;
        color: #eceff4;
        padding: 10px;
        border-radius: 4px;
        font-family: monospace;
      }

      #start-btn {
        background: #88c0d0;
        color: #151515;
        border: none;
        padding: 12px 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        text-transform: uppercase;
        border-radius: 4px;
        width: 100%;
        transition: transform 0.1s, background 0.3s;
      }

      #start-btn:hover {
        background: #8fbcbb;
        transform: scale(1.02);
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
          "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="modal-overlay">
      <div id="modal-box">
        <h2>Model Configuration</h2>
        <p>Edit the training text:</p>
        <textarea id="corpus-input" spellcheck="false"></textarea>

        <div class="settings-row">
          <div class="input-group">
            <label>Output Size (Tokens)</label>
            <input type="number" id="output-size" value="8" min="1" max="20" />
          </div>
          <div class="input-group">
            <label>Markov Order (N-Gram)</label>
            <input type="number" id="markov-order" value="1" min="1" max="3" />
          </div>
        </div>

        <button id="start-btn">Start Simulation</button>
      </div>
    </div>

    <div id="title-overlay">
      Pipeline NLP
      <span id="step-desc" class="subtitle">Initializing...</span>
    </div>

    <div id="debug-console">Status: Configuring...</div>
    <div id="canvas-container"></div>

    <div id="ui">
      <div class="btn-group">
        <button id="btn-prev">Previous</button>
        <button id="btn-next">Next</button>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import gsap from "gsap";

      let config = {
        outputSize: 8,
        order: 1,
        text: "",
      };

      const DEFAULT_CORPUS = `Neural networks learn patterns from data.
Data creates logic within networks.
Logic is the foundation of machine intelligence.
Intelligence emerges from complex patterns.
Patterns hide inside the machine code.
Deep learning transforms raw input.
Input vectors map to hidden spaces.
Spaces define the geometry of thought.
Thought propagates through layered structures.
Structures adapt when gradients reshape them.
Gradients flow across computational graphs.
Graphs represent relationships between abstractions.
Abstractions compress meaning from information.
Information becomes knowledge through optimization.
Optimization aligns models with real-world behavior.
Behavior evolves as representations refine.
Representations form the internal language of models.
Models interpret signals through learned hierarchies.`;

      class MarkovChain {
        constructor(order = 1) {
          this.order = order;
          this.vocab = {};
          this.inverseVocab = [];
          this.transitions = {};
          this.startSequences = [];
          this.processedData = [];
        }

        clean(text) {
          const rawLines = text.trim().split("\n");
          return rawLines
            .map((line) => {
              const original = line.trim();
              const cleaned = original
                .toLowerCase()
                .replace(/[^\w\s]/g, "")
                .replace(/\s+/g, " ");
              return { original, cleaned };
            })
            .filter((obj) => obj.cleaned.length > 0);
        }

        train(text) {
          const cleanPairs = this.clean(text);
          this.processedData = cleanPairs;
          let idCounter = 0;

          cleanPairs.forEach((pair) => {
            const tokens = pair.cleaned.split(" ");

            pair.tokenIds = tokens.map((token) => {
              if (!(token in this.vocab)) {
                this.vocab[token] = idCounter;
                this.inverseVocab[idCounter] = token;
                idCounter++;
              }
              return this.vocab[token];
            });

            const ids = pair.tokenIds;

            if (ids.length <= this.order) return;

            for (let i = 0; i < ids.length - this.order; i++) {
              const stateBuffer = ids.slice(i, i + this.order);

              if (i === 0) this.startSequences.push(stateBuffer);

              const stateKey = stateBuffer.join(",");
              const nextId = ids[i + this.order];

              if (!this.transitions[stateKey]) this.transitions[stateKey] = {};
              if (!this.transitions[stateKey][nextId])
                this.transitions[stateKey][nextId] = 0;
              this.transitions[stateKey][nextId]++;
            }
          });
        }

        predictNext(currentBuffer) {
          const stateKey = currentBuffer.join(",");
          const possibilities = this.transitions[stateKey];

          if (!possibilities) return null;

          const candidates = Object.entries(possibilities);
          const totalWeight = candidates.reduce((sum, [_, w]) => sum + w, 0);
          let random = Math.random() * totalWeight;

          for (const [nextIdStr, weight] of candidates) {
            random -= weight;
            if (random <= 0) return parseInt(nextIdStr);
          }
          return parseInt(candidates[0][0]);
        }

        getRandomStart() {
          if (this.startSequences.length === 0)
            return Array(this.order).fill(0);
          return [
            ...this.startSequences[
              Math.floor(Math.random() * this.startSequences.length)
            ],
          ];
        }
      }

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050505);

      const camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(0, 0, 100);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document
        .getElementById("canvas-container")
        .appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.AmbientLight(0xffffff, 0.3));
      const spotLight = new THREE.SpotLight(0x88c0d0, 50);
      spotLight.position.set(10, 40, 40);
      scene.add(spotLight);

      const groupInput = new THREE.Group();
      const groupTransition = new THREE.Group();
      const groupOutput = new THREE.Group();
      scene.add(groupInput, groupTransition, groupOutput);

      const COLOR_RAW = 0x88c0d0;
      const COLOR_CLEAN = 0xa3be8c;
      const COLOR_NUM = 0xd08770;
      const COLOR_BRACKET = 0x4c566a;

      let font = null;
      let model = null;

      let pipelineData = { inputDims: { w: 0, h: 0 }, graphRadius: 0 };
      let gridCells = [];
      let nodeMeshes = [];
      let outputMeshes = [];

      function getFitZ(height, fov) {
        return (height / 2 / Math.tan((fov * Math.PI) / 360)) * 1.2;
      }

      const createText = (str, color, size = 0.8) => {
        const safeStr =
          str !== undefined && str !== null ? str.toString() : "?";
        const geo = new TextGeometry(safeStr, {
          font: font,
          size: size,
          height: 0.02,
          curveSegments: 2,
        });
        geo.center();
        const mat = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 1,
        });
        return new THREE.Mesh(geo, mat);
      };

      const createBracket = (height, isLeft) => {
        const width = Math.max(0.5, height * 0.02);
        const path = new THREE.Path();
        const h2 = height / 2;
        if (isLeft) {
          path.moveTo(width, h2);
          path.lineTo(0, h2);
          path.lineTo(0, -h2);
          path.lineTo(width, -h2);
        } else {
          path.moveTo(-width, h2);
          path.lineTo(0, h2);
          path.lineTo(0, -h2);
          path.lineTo(-width, -h2);
        }
        const geo = new THREE.BufferGeometry().setFromPoints(path.getPoints());
        return new THREE.Line(
          geo,
          new THREE.LineBasicMaterial({ color: COLOR_BRACKET, linewidth: 2 })
        );
      };

      function buildInputGrid(rows, maxCols) {
        const ROW_H = 2.5;
        const COL_W = 6.0;
        const totalHeight = rows * ROW_H;
        const totalWidth = maxCols * COL_W;
        pipelineData.inputDims = { w: totalWidth, h: totalHeight };

        const bL = createBracket(totalHeight + 1, true);
        bL.position.set(-totalWidth / 2 - 1, 0, 0);
        const bR = createBracket(totalHeight + 1, false);
        bR.position.set(totalWidth / 2 + 1, 0, 0);
        groupInput.add(bL, bR);

        const startX = -totalWidth / 2 + COL_W / 2;
        const startY = totalHeight / 2 - ROW_H / 2;

        model.processedData.forEach((rowObj, r) => {
          const words = rowObj.cleaned.split(" ");
          const rawWords = rowObj.original.split(" ");

          words.forEach((cleanWord, c) => {
            const x = startX + c * COL_W;
            const y = startY - r * ROW_H;

            const rawTxt = rawWords[c] ? rawWords[c] : cleanWord;
            const rawMesh = createText(rawTxt, COLOR_RAW, 0.7);
            rawMesh.position.set(x, y, 0);

            const cleanMesh = createText(cleanWord, COLOR_CLEAN, 0.7);
            cleanMesh.position.set(x, y, 0);
            cleanMesh.material.opacity = 0;

            const id = model.vocab[cleanWord];
            const idMesh = createText(id, COLOR_NUM, 1.0);
            idMesh.position.set(x, y, 0);
            idMesh.scale.set(0, 0, 0);

            groupInput.add(rawMesh, cleanMesh, idMesh);
            gridCells.push({ rawMesh, cleanMesh, idMesh });
          });
        });
      }

      function buildGraph(vocabSize) {
        const nodeSpacing = 3.0;
        const circumference = vocabSize * nodeSpacing;
        const radius = Math.max(15, circumference / (2 * Math.PI));
        pipelineData.graphRadius = radius;

        const ORDER_COLORS = [0xd14d53, 0xa3be8c, 0x88c0d0];

        for (let i = 0; i < vocabSize; i++) {
          const angle = (i / vocabSize) * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;

          const idMesh = createText(i, COLOR_NUM, 1.2);
          idMesh.position.set(x, y, 0);

          const label = createText(model.inverseVocab[i], COLOR_CLEAN, 0.5);
          const xL = Math.cos(angle) * (radius + 3.0);
          const yL = Math.sin(angle) * (radius + 3.0);
          label.position.set(xL, yL, 0);

          const g = new THREE.Group();
          g.add(idMesh, label);
          groupTransition.add(g);

          nodeMeshes[i] = { mesh: g, pos: new THREE.Vector3(x, y, 0) };
        }

        const baseOpacity = 0.6;

        Object.keys(model.transitions).forEach((key) => {
          const contextIds = key.split(",").map((id) => parseInt(id));
          const targets = model.transitions[key];

          Object.keys(targets).forEach((toId) => {
            const pDest = nodeMeshes[toId].pos;

            contextIds.forEach((fromId, index) => {
              const pSource = nodeMeshes[fromId].pos;

              const colorHex = ORDER_COLORS[index % ORDER_COLORS.length];

              const mid = pSource.clone().add(pDest).multiplyScalar(0.5);

              mid.multiplyScalar(1.2 + index * 0.1);
              mid.z += 6 + index * 4;

              const curve = new THREE.QuadraticBezierCurve3(
                pSource,
                mid,
                pDest
              );
              const geo = new THREE.BufferGeometry().setFromPoints(
                curve.getPoints(12)
              );

              const mat = new THREE.LineBasicMaterial({
                color: colorHex,
                transparent: true,
                opacity: baseOpacity,
                linewidth: 2,
              });

              groupTransition.add(new THREE.Line(geo, mat));
            });
          });
        });

        groupTransition.visible = false;
      }

      const steps = [
        null,
        () => {
          document.getElementById("step-desc").innerText = "1. Raw Input";

          gsap.killTweensOf(camera.position);
          gsap.killTweensOf(groupInput.scale);

          const zFit = getFitZ(pipelineData.inputDims.h, camera.fov);
          const zSafe = Math.max(zFit, 40);

          gsap.to(camera.position, {
            x: 0,
            y: 0,
            z: zSafe,
            duration: 1.5,
            ease: "power2.inOut",
          });

          groupInput.visible = true;
          groupInput.scale.set(1, 1, 1);
          groupTransition.visible = false;
          groupOutput.visible = false;

          gridCells.forEach((c) => {
            c.rawMesh.scale.set(1, 1, 1);
            c.cleanMesh.scale.set(1, 1, 1);
            c.idMesh.scale.set(0, 0, 0);

            gsap.to(c.rawMesh.material, { opacity: 1, duration: 1 });
            gsap.to(c.cleanMesh.material, { opacity: 0, duration: 1 });
            gsap.to(c.idMesh.material, { opacity: 0, duration: 0.5 });
          });
        },

        () => {
          document.getElementById("step-desc").innerText =
            "2. Cleaning (Normalization)";

          groupInput.visible = true;
          gsap.to(groupInput.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
          groupTransition.visible = false;

          gridCells.forEach((c, i) => {
            gsap.set(c.cleanMesh.scale, { x: 1, y: 1, z: 1 });
            gsap.set(c.idMesh.scale, { x: 0, y: 0, z: 0 });

            gsap.to(c.rawMesh.material, {
              opacity: 0,
              duration: 0.5,
              delay: i * 0.01,
            });
            gsap.to(c.cleanMesh.material, {
              opacity: 1,
              duration: 0.5,
              delay: i * 0.01 + 0.2,
            });
          });
        },

        () => {
          document.getElementById("step-desc").innerText =
            "3. Tokenization (ID Map)";

          groupInput.visible = true;
          groupTransition.visible = false;

          gsap.to(groupInput.scale, { x: 1, y: 1, duration: 0.5 });
          gsap.killTweensOf(camera.position);

          gridCells.forEach((c, i) => {
            c.cleanMesh.material.opacity = 1;
            c.rawMesh.material.opacity = 0;

            c.idMesh.material.opacity = 1;

            gsap.set(c.idMesh.scale, { x: 0, y: 0, z: 0 });
            gsap.set(c.cleanMesh.scale, { x: 1, y: 1, z: 1 });

            gsap.to(c.cleanMesh.scale, {
              x: 0,
              y: 0,
              z: 0,
              duration: 0.4,
              delay: i * 0.01,
            });

            gsap.to(c.idMesh.scale, {
              x: 1,
              y: 1,
              z: 1,
              duration: 0.4,
              delay: i * 0.01 + 0.2,
              ease: "back.out(1.7)",
            });
          });
        },

        () => {
          document.getElementById(
            "step-desc"
          ).innerText = `4. Graph (Order: ${config.order})`;

          const zFit = getFitZ(pipelineData.graphRadius * 2.5, camera.fov);
          gsap.to(camera.position, { x: 0, y: 0, z: zFit, duration: 1.5 });

          gsap.to(groupInput.scale, { x: 0, y: 0, duration: 0.5 });

          groupTransition.visible = true;
          gsap.to(groupTransition.scale, {
            x: 1,
            y: 1,
            z: 1,
            duration: 1,
          });

          groupOutput.visible = false;
        },

        () => {
          const genLen = config.outputSize;
          document.getElementById(
            "step-desc"
          ).innerText = `5. Generation (${genLen} Tokens)`;
          const zSafe = Math.max(50, pipelineData.graphRadius * 4);
          const POS_OUT_X = pipelineData.graphRadius + 10;

          gsap.to(camera.position, {
            x: POS_OUT_X,
            y: 0,
            z: zSafe,
            duration: 1.5,
          });

          groupTransition.visible = true;
          groupTransition.scale.set(1, 1, 1);

          groupOutput.visible = true;

          outputMeshes.forEach((m) => {
            groupOutput.remove(m.id);
            groupOutput.remove(m.word);
          });
          outputMeshes = [];

          const stepH = 3.0;
          const vectorH = genLen * stepH;

          groupOutput.clear();
          const bL = createBracket(vectorH, true);
          bL.position.set(POS_OUT_X - 4, 0, 0);
          const bR = createBracket(vectorH, false);
          bR.position.set(POS_OUT_X + 4, 0, 0);
          groupOutput.add(bL, bR);

          let currBuffer = model.getRandomStart();
          const tl = gsap.timeline();

          for (let i = 0; i < genLen; i++) {
            const y = (genLen - 1) * (stepH / 2) - i * stepH;
            const visualId = currBuffer[currBuffer.length - 1];

            const node = nodeMeshes[visualId];
            if (node) {
              tl.to(node.mesh.children[0].material, {
                color: 0xffffff,
                duration: 0.1,
              });
              tl.to(node.mesh.children[0].material, {
                color: COLOR_NUM,
                duration: 0.2,
              });
            }

            const token = createText(visualId, COLOR_NUM, 1.0);
            if (node) token.position.copy(node.pos);
            else token.position.set(0, 0, 0);

            groupOutput.add(token);

            tl.to(token.position, {
              x: POS_OUT_X,
              y: y,
              z: 0,
              duration: 0.6,
              ease: "power2.inOut",
            });

            const word = createText(
              model.inverseVocab[visualId],
              COLOR_CLEAN,
              0.8
            );
            word.position.set(POS_OUT_X, y, 0);
            word.scale.set(0, 0, 0);
            word.rotation.set(0, 0, 0);
            groupOutput.add(word);

            outputMeshes.push({ id: token, word: word });

            const nextId = model.predictNext(currBuffer);
            if (nextId !== null) {
              currBuffer.shift();
              currBuffer.push(nextId);
            } else {
              currBuffer = model.getRandomStart();
            }
          }
        },

        () => {
          document.getElementById("step-desc").innerText = "6. Final Result";
          const POS_OUT_X = pipelineData.graphRadius + 10;

          gsap.to(camera.position, {
            x: POS_OUT_X,
            y: 0,
            z: 120,
            duration: 1.5,
          });

          outputMeshes.forEach((m, i) => {
            gsap.set(m.id.scale, { x: 1, y: 1, z: 1 });
            gsap.set(m.id.rotation, { x: 0 });
            gsap.set(m.word.scale, { x: 0, y: 0, z: 0 });

            const tl = gsap.timeline({ delay: i * 0.1 });
            tl.to(m.id.rotation, { x: Math.PI / 2, duration: 0.3 });
            tl.to(m.id.scale, { x: 0, y: 0, z: 0, duration: 0.1 });
            tl.to(m.word.scale, {
              x: 1,
              y: 1,
              z: 1,
              duration: 0.5,
              ease: "elastic.out(1, 0.5)",
            });
          });
        },
      ];

      let currentStep = 1;
      const loader = new FontLoader();

      loader.load(
        "https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json",
        (f) => {
          font = f;
          const textArea = document.getElementById("corpus-input");
          textArea.value = DEFAULT_CORPUS;

          document.getElementById("start-btn").addEventListener("click", () => {
            // 1. Coletar Dados
            config.text = textArea.value;
            config.outputSize =
              parseInt(document.getElementById("output-size").value) || 8;
            config.order =
              parseInt(document.getElementById("markov-order").value) || 1;

            if (!config.text.trim()) {
              alert("Texto vazio!");
              return;
            }

            // 2. UI Feedback
            const modal = document.getElementById("modal-overlay");
            modal.style.opacity = 0;
            setTimeout(() => (modal.style.display = "none"), 500);

            // 3. Iniciar
            initPipeline();
          });
        }
      );

      async function initPipeline() {
        document.getElementById("title-overlay").style.opacity = 1;
        document.getElementById("ui").style.opacity = 1;
        document.getElementById("debug-console").style.opacity = 1;
        document.getElementById("step-desc").innerText = "Training Model...";

        await new Promise((r) => setTimeout(r, 500));

        model = new MarkovChain(config.order);
        model.train(config.text);

        const rows = model.processedData.length;
        const maxTokens = Math.max(
          ...model.processedData.map((d) => d.tokenIds.length)
        );

        document.getElementById("debug-console").innerHTML = `
           Status: Ready<br>
           Vocab: ${model.inverseVocab.length}<br>
           Order: ${config.order}<br>
           Output: ${config.outputSize}
        `;

        buildInputGrid(rows, maxTokens);
        buildGraph(model.inverseVocab.length);

        currentStep = 1;
        steps[1]();
      }

      document.getElementById("btn-next").onclick = () => {
        if (currentStep < steps.length - 1) {
          currentStep++;
          steps[currentStep]();
        }
      };
      document.getElementById("btn-prev").onclick = () => {
        if (currentStep > 1) {
          currentStep--;
          steps[currentStep]();
        }
      };

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
